---
title: 超算杯——鱼类分类
date: 2019-10-02 11:51:12
tags: 鱼类分类 cnn
categories: Project
---
# 对鱼类进行分类
<!--more-->
### 有些事，勇敢的去做了，就成功了一半。     -我说的，哈哈哈  初赛过了，挺意外，决赛好好弄。初赛要求：给了25类鱼的图片数据，要求输出到txt中种类，z为不属于25类中的其他，predict.py运行在python命令行下输入：python T43498920_test.py /home/test_images T43498920_test.txt即可运行，结果保存在txt中。
```
模型设计采用python语言，keras框架。这种子类别图像分类本应该首先找到前景对象 (鱼 )及其局部区域, 之后分别对这些区域提取特征，对所得到的特征进行适当的处理之后, 用来完成分类器的训练和预测，但采用最简单的cnn进行图像分类后发现结果还可以，于是便采用了直接对整幅图像进行读取训练。
      数据读取部分：依次读入标注数据文件夹下的图片，并将其更改大小resize为224*224，将其转为数组img_to_array，存入data列表中，同时将标签（1,2,3...）存入labels列表中。将data列表转化为数组，除以255.0，labels列表也转为数组，以8:2的比例分为训练数据和测试数据。数据增强进行了水平翻转，旋转，水平垂直平移。
      模型搭建：建立一个CNN模型，一层卷积、一层池化、一层卷积、一层池化、抹平之后进行全链接、最后进行分类，其中flatten是将多维输入一维化的函数，dense是全连接层，最后以softmax激活函数计算和为1的概率。
      模型预测：载入模型，将测试图片依次读入，并改为224*224大小，转为数组并除以225.0，取概率最大的为预测结果，经过在未标注数据上的测试，噪声的预测结果基本都小于0.94，小于0.94的预测为z类。
```
net.py构建网络
{% fold 点击显/隐内容 %}
```python
 # -*- coding: utf-8 -*-
from keras.models import Sequential
from keras.preprocessing.image import ImageDataGenerator
from keras.layers import Conv2D,MaxPooling2D,Dense,Flatten,Activation,Dropout
from keras.preprocessing.image import img_to_array
from sklearn.model_selection import train_test_split
from keras.utils import to_categorical
from keras.optimizers import Adam
import numpy as np
import random
import cv2
import os



def Build(width,height,depth,classes):
    inputShape = (height, width, depth)
    #first
    model=Sequential()
    model.add(Conv2D(20,(5,5),padding='same',input_shape=inputShape))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2,2),strides=(2,2)))
    #second
    model.add(Conv2D(50, (5, 5), padding='same'))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
    #fc
    model.add(Flatten())
    model.add(Dense(500))
    model.add(Activation('relu'))
    #dropout
    model.add(Dropout(0.4))
    #fc
    model.add(Dense(25))
    model.add(Activation('softmax'))
    return model

def load_data():
    random.seed(1)
    t=-1
    data=[]
    labels=[]
    dir = "D:/BaiduNetdiskDownload/T1_ImageData/"
    for i in os.listdir(dir):
        t+=1
        dir = "D:/BaiduNetdiskDownload/T1_ImageData/%s/标注数据/" % i
        for photo in os.listdir(dir):
            path = dir + "%s" % photo
            image = cv2.imdecode(np.fromfile(path, dtype=np.uint8), -1)
            try:
                if image is not None and image.shape[2] == 3:
                    # print(path)
                    image = cv2.resize(image, (224, 224))
                    image = img_to_array(image)

                    data.append(image)
                    labels.append(t)
            except:
                continue

    data = np.array(data, dtype="float")
    data= np.true_divide(data,255.0)
    labels = np.array(labels)
    (trainX, testX, trainY, testY) = train_test_split(data,labels, test_size=0.2, random_state=1)
    trainY = to_categorical(trainY, num_classes=25)
    testY = to_categorical(testY, num_classes=25)

    return trainX, trainY, testX, testY

def train(trainX,trainY,testX,testY):
    EPOCHS=200
    BS=32
    model= Build(width=224, height=224, depth=3, classes=25)
    adm= Adam(lr=1e-3)
    model.compile(loss="categorical_crossentropy", optimizer=adm,metrics=["accuracy"])
    aug = ImageDataGenerator(rotation_range=30, width_shift_range=0.1,
        height_shift_range=0.1, shear_range=0.2, zoom_range=0.2,
        horizontal_flip=True, fill_mode="nearest")

    H = model.fit_generator(aug.flow(trainX, trainY, batch_size=BS),
        validation_data=(testX, testY), steps_per_epoch=len(trainX) // BS,
        epochs=EPOCHS, verbose=1)
    # 评估模型
    loss, accuracy = model.evaluate(testX,testY)


    model.save('model-32.h5')

if __name__ == '__main__':
    trainX, trainY, testX, testY =load_data()
    train(trainX, trainY, testX, testY)
```
{% endfold %}

预测predict.py
{% fold 点击显/隐内容 %}
```python
 # -*- coding: utf-8 -*-
from keras.preprocessing.image import img_to_array
from keras.models import load_model
import numpy as np
np.set_printoptions(suppress=True)
import cv2
import sys
import os

path=sys.argv[1]
txtname=sys.argv[2]
path="%s/"%path

Class=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"]
model=load_model("model-200.h5")
f = open("%s"%txtname, "w+")
path_list=os.listdir(path)
path_list.sort()
for photo in path_list:
    dir=path+photo
    image = cv2.imread(dir)
    try:
        if image is not None and image.shape[2] == 3:
            image = cv2.resize(image, (224, 224))
            image = image.astype("float")
            image = np.true_divide(image, 255.0)
            image = img_to_array(image)
            image = np.expand_dims(image, axis=0)
            predict = model.predict(image)
            acc = np.max(predict)
            result = np.argmax(predict, axis=1)
            fishclass=Class[result[0]]
            if(acc<0.94):
                fishclass="Z"
            #print(predict*100)
            print("%s  %s  %s" % (photo, acc * 100, fishclass))

            f.write("%s,%s\n"%(photo,fishclass))
    except:
        continue
f.close()
```
{% endfold %}